#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>

static void make_guard(char *dst, size_t dst_size, const char *base) {

	snprintf(dst, dst_size, "ASSET_%s_H", base);
	for (size_t i = 0; dst[i]; ++i) {
		if (!isalnum((unsigned char)dst[i])) {
			dst[i] = '_';
		} else {
			dst[i] = toupper((unsigned char)dst[i]);
		}
	}
}

int main(int argc, char **argv) {

	if (argc < 2) {
		fprintf(stderr, "usage: %s file.obj\n", argv[0]);
		return EXIT_FAILURE;
	}

	FILE* in_obj = fopen(argv[1], "r");
	if (!in_obj) {
		perror("fopen input");
		return EXIT_FAILURE;
	}

	// compute base name (strip extension if present)
	const char* dot = strrchr(argv[1], '.');
	size_t base_len = dot ? (size_t)(dot - argv[1]) : strlen(argv[1]);

	char base[256];
	if (base_len >= sizeof(base)) base_len = sizeof(base) - 1;
	memcpy(base, argv[1], base_len);
	base[base_len] = '\0';

	// asset and type names
	char type_name[256];
	char* base_dup = strdup(base);
	base_dup[0] = toupper(base_dup[0]);
	snprintf(type_name, sizeof(type_name), "Asset%s", base_dup);

	char header_file[256];
	snprintf(header_file, sizeof(header_file), "asset_%s.h", base);

	char guard[256];
	make_guard(guard, sizeof(guard), base);

	FILE *out_h = fopen(header_file, "w");
	if (!out_h) {
		perror("fopen output");
		fclose(in_obj);
		return EXIT_FAILURE;
	}

	// first pass: count vertices and faces
	size_t vertex_count = 0;
	size_t face_count = 0;

	char *line = NULL;
	size_t len = 0;
	ssize_t read;

	while ((read = getline(&line, &len, in_obj)) != -1) {
		if (read == 0) continue;
		if (line[0] == 'v' && line[1] == ' ') {
		    vertex_count++;
		} else if (line[0] == 'f' && line[1] == ' ') {
		    face_count++;
		}
	}

	// prepare header
	fprintf(out_h, "// This asset was automatically generated by objToC.\n\n");
	fprintf(out_h, "#ifndef %s\n#define %s\n\n", guard, guard);

	fprintf(out_h, "typedef struct {\n");
	fprintf(out_h, "\tsize_t v_count;\n");
	fprintf(out_h, "\tsize_t f_count;\n");
	fprintf(out_h, "\tV3f v[%zu];\n", vertex_count);
	fprintf(out_h, "\tV3u f[%zu];\n", face_count);
	fprintf(out_h, "} %s;\n\n", type_name);

	fprintf(out_h, "static const %s asset_%s = {\n", type_name, base);
	fprintf(out_h, "\t.v_count = %zu,\n", vertex_count);
	fprintf(out_h, "\t.f_count = %zu,\n", face_count);

	// second pass: output data
	rewind(in_obj);

	size_t count = 0;
	while ((read = getline(&line, &len, in_obj)) != -1) {

		if (read == 0) continue;

		if (line[0] == 'v' && line[1] == ' ') {

			if (count == 0) fprintf(out_h, "\t.v = {\n");

			char* buf = strdup(line);
			if (!buf) {
				perror("strdup");
				break;
			}

			char* tok0 = strtok(buf,  " \n\t");
			char* tok1 = strtok(NULL, " \n\t");
			char* tok2 = strtok(NULL, " \n\t");
			char* tok3 = strtok(NULL, " \n\t");

			if (!tok1 || !tok2 || !tok3) {
				fprintf(stderr, "Malformed vertex line: %s", line);
				free(buf);
				continue;
			}

			if (count < vertex_count - 1) {
				fprintf(out_h, "\t\t{{ %s, %s, %s }},\n", tok1, tok2, tok3);
				count += 1;
			} else {
				fprintf(out_h, "\t\t{{ %s, %s, %s }}\n", tok1, tok2, tok3);
				fprintf(out_h, "\t},\n");
				count = 0;
			}

			free(buf);

		} else if (line[0] == 'f' && line[1] == ' ') {

			if (count == 0) fprintf(out_h, "\t.f = {\n");

			char* buf = strdup(line);
			if (!buf) {
				perror("strdup");
				break;
			}

			char* tok0 = strtok(buf,  " \n\t");
			char* tok1 = strtok(NULL, " \n\t");
			char* tok2 = strtok(NULL, " \n\t");
			char* tok3 = strtok(NULL, " \n\t");

			if (strchr(tok1, '/')) {
				tok1 = strtok(tok1, "/");
				tok2 = strtok(tok2, "/");
				tok3 = strtok(tok3, "/");
			}

			if (count < face_count - 1) {
				fprintf(out_h, "\t\t{{ %s, %s, %s }},\n", tok1, tok2, tok3);
				count += 1;
			} else {
				fprintf(out_h, "\t\t{{ %s, %s, %s }}\n", tok1, tok2, tok3);
				fprintf(out_h, "\t}\n");
				count = 0;
			}

			free(buf);
		}
	}

	fprintf(out_h, "};\n\n#endif /* %s */\n", guard);

	free(line);
	fclose(in_obj);
	fclose(out_h);
	return EXIT_SUCCESS;
}

